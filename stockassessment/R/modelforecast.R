
.forecastDefault <- function(){
    ## list(specification = "DEFAULT_NOT_TO_BE_USED",
    ##      Amin = NA_real_,
    ##      Amax = NA_real_,
    ##      fleet = NA_real_,
    ##      relative = 0,
    ##      cstr = as.numeric(99),
    ##      target = NA_real_)
    list()
}

.parseRel <- function(type,s){
    if(s == ""){                        #Absolute value
        return(-3)
    }
    if(s == "*")                      #Relative to last year
        return(-2)
    ## Check relative to same type of value
    if(as.character(type) != gsub("(\\*)(F|C|SSB|TSB|L)(.*)","\\2",s))
        stop(sprintf("%s values can only be relative to %s values",as.character(type),as.character(type)))
    ## Find relative type
    if(grepl("^\\*(F|C|SSB|TSB|L)$",s)){ #Relative to total
        return(-1)
    }else if(grepl("^\\*(F|C|SSB|TSB|L)(\\[[[:digit:]]+\\])$",s)){
        return(as.numeric(gsub("(^\\*(F|C|SSB|TSB|L))(\\[)([[:digit:]]+)(\\]$)","\\4",s))-1)
    }
    stop("Wrong specification of relative value. Relative values can only specify a fleet")
}

.parseForecast <- function(s, FbarRange, fleetTypes, ageRange){
    nCF <- sum(fleetTypes == 0)
    ## Split constraints
    sL <- strsplit(s,"[[:space:]]*&+[[:space:]]*")
    forecastEnum <- c("F","C","SSB","TSB","L","KeepRelF")
    parseOne <- function(ss){
        frmt <- "(F|C|SSB|TSB|L)(\\[.+\\])?(=)([[:digit:]]*\\.?[[:digit:]]*)(\\*.*)?"
        type <- factor(gsub(frmt,"\\1",ss),forecastEnum)
        spec <- gsub(frmt,"\\2",ss)
        target <- log(as.numeric(gsub(frmt,"\\4",ss)))
        if(is.na(target))
            stop("wrong specification of forecast target")
        rel <- .parseRel(type,gsub(frmt,"\\5",ss))
        if(is.na(rel) || !is.numeric(rel) || rel < -3){
            stop("wrong specification of relative value")
        }

        if(spec == ""){                 # Not specified
            Amin <- as.numeric(ifelse(type=="F",FbarRange[1],ageRange[1]))
            Amax <- as.numeric(ifelse(type=="F",FbarRange[2],ageRange[2]))
            fleet <- -1
        }else if(grepl("\\[[[:digit:]]+,[[:digit:]]+-[[:digit:]]+\\]",spec)){ # Fully specified
            Amin <- as.numeric(gsub("(\\[)([[:digit:]]+)(,)([[:digit:]]+)(-)([[:digit:]]+)(\\])","\\4",spec))
            Amax <- as.numeric(gsub("(\\[)([[:digit:]]+)(,)([[:digit:]]+)(-)([[:digit:]]+)(\\])","\\6",spec))
            fleet <- as.numeric(gsub("(\\[)([[:digit:]]+)(,)([[:digit:]]+)(-)([[:digit:]]+)(\\])","\\2",spec))-1
        }else if(grepl("\\[[[:digit:]]+\\]",spec)){ # Fleet specified
            Amin <- as.numeric(ifelse(type=="F",FbarRange[1],ageRange[1]))
            Amax <- as.numeric(ifelse(type=="F",FbarRange[2],ageRange[2]))
            fleet <- as.numeric(gsub("(\\[)([[:digit:]]+)(\\])","\\2",spec))-1
        }else if(grepl("\\[[[:digit:]]+-[[:digit:]]+\\]",spec)){ # Age range specified
            Amin <- as.numeric(gsub("(\\[)([[:digit:]]+)(-)([[:digit:]]+)(\\])","\\2",spec))
            Amax <- as.numeric(gsub("(\\[)([[:digit:]]+)(-)([[:digit:]]+)(\\])","\\4",spec))
            fleet <- -1
        }else{ #Wrongly specified
            stop("Wrong specification of forecast")
        }
        if((type == "SSB" || type == "TSB") && fleet >= 0){
            warning("For SSB and TSB constraints, fleet should not be set")
            fleet <- -1
        }
        if(Amin < ageRange[1] || Amax > ageRange[2])
            stop("Specified ages not in age range of model")
        if(fleet >= nCF)
            stop("fleet number is too high")
        if(rel >= nCF)
            stop("relative fleet number is too high")
        if(rel == fleet)
            stop("A fleet cannot be relative to itself")
        v <- list(specification = ss,
                  Amin = Amin,
                  Amax = Amax,
                  fleet = fleet,
                  relative = rel,
                  cstr = as.numeric(type)-1,
                  target = target)
        v
    }
    cstr <- lapply(sL,function(x)lapply(x,parseOne))
    ## Add constraints to fully specify
    fleetsSpec <- lapply(cstr,function(xx) factor(sapply(xx,function(yy)yy$fleet),c(-1,seq_len(nCF)-1)))
    if(any(unlist(sapply(fleetsSpec,is.na))))
        stop("Fleet numbers should be from 1 to the number of residual catch fleets")
    ft <- lapply(fleetsSpec,table)
    if(any(sapply(ft, function(x) any(x>1) || sum(x) > nCF)))
        stop("Each fleet/total can only have one constraint and there can not be more constraints than fleets")
    makeRelCon <- function(f1,f2){
        list(specification = sprintf("AUTOGENERATED~F%d/F%d",f2,f1),
             Amin = FbarRange[1],
             Amax = FbarRange[2],
             fleet = as.numeric(f1)-1,
             relative = as.numeric(f2)-1,
             cstr = as.numeric(factor("KeepRelF",forecastEnum))-1,
             target = 0)  
    }
    cToAdd <- lapply(ft,function(x){
        ii <- unname(which(x[-1]==0))
        if(length(ii) > 1){
            return(lapply(ii[-1],makeRelCon,f1=ii[1]))
        }
        list()
    })
    lapply(seq_along(cstr), function(i){
        c(cstr[[i]], cToAdd[[i]])
    })
}




##' Model based forecast function
##' @rdname modelforecast 
##' @param fit an assessment object of type sam, as returned from the function sam.fit
##' @param ... other variables used by the methods
##' @export
modelforecast <- function(fit, ...){
    UseMethod("modelforecast")
}

##' Model based forecast function
##' @param constraints a character vector of forecast constraint specifications
##' @param fscale a vector of f-scales. See details.  
##' @param catchval a vector of target catches. See details.
##' @param fval a vector of target f values. See details.
##' @param nextssb a vector target SSB values the following year. See details.
##' @param landval a vector of target catches. See details.   
##' @param findMSY Should not be used. See \link{forecastMSY}.
##' @param hcr Should not be used. See \link{hcr}.
##' @param nosim number of simulations. If 0, the Laplace approximation is used for forecasting.
##' @param year.base starting year default last year in assessment. Currently it is only supported to use last assessment year or the year before  
##' @param ave.years vector of years to average for weights, maturity, M and such  
##' @param rec.years vector of years to use to resample recruitment from. If the vector is empty, the stock recruitment model is used.
##' @param label optional label to appear in short table
##' @param overwriteSelYears if a vector of years is specified, then the average selectivity of those years is used (not recommended)
##' @param deterministicF option to set F variance to (almost) zero (not recommended)
##' @param processNoiseF option to turn off process noise in F
##' @param resampleFirst Resample base year when nosim > 0?
##' @param customSel supply a custom selection vector that will then be used as fixed selection in all years after the final assessment year (not recommended)
##' @param lagR if the second youngest age should be reported as recruits
##' @param splitLD if TRUE the result is split in landing and discards
##' @param addTSB if TRUE the total stock biomass (TSB) is added
##' @param biasCorrect Do bias correction of reported variables. Can be turned off to reduce running time (not recommended).
##' @param returnAllYears If TRUE, all years are bias corrected. Otherwise, only forecast years are corrected.
##' @param nCatchAverageYears Should not be used. See \link{forecastMSY}.
##' @param returnObj Only return TMB object?
##' @param hcrConf Should not be used. See \link{hcr}.
##' @param hcrCurrentSSB Should not be used. See \link{hcr}.
##' @param progress Show progress bar for simulations?
##' @param estimate the summary function used (typically mean or median) for simulations
##' @param silent Passed to MakeADFun. Should the TMB object be silent?
##' @param newton_config Configuration for newton optimizer to find F values. See ?TMB::newton for details. Use NULL for TMB defaults.
##' @details
##' Function to forecast the model under specified catch constraints. In the forecast, catch constraints are used to set the mean of the \eqn{log(F)} process. Therefore, catch constraints are not matched exactly in individual simulations (unlike the forecast function simulations). Likewise, the summary of a specific set of simulations will not match exactly due to random variability.
##' By default, recruitment is forecasted using the estimated recruitment model. If a vector of recruitment years is given, recruitment is forecasted using a log-normal distribution with the same mean and variance as the recruitment in the years given. This is different from the forecast function, which samples from the recruitment estimates.
##' Catch scenarios are specified by a vector of target constraints. The first value determines F in the year after the base year.
##'
##' @section F based constraints:
##' Forecasts for F values are specified by the format "F[f,a0-a1]=x" where f is the residual catch fleet and a0-a1 is an age range. For example, "F[2,2-4]=0.3" specifies that the average F for the second fleet over ages 2-4 should be 0.3.
##' If an "*" is added to the target value, the target will be relative to the year before. For example, "F[2,2-4]=0.9*" specifies that the average F for the second fleet over ages 2-4 should be 90% of the year before. Further, the target for a fleet can be relative to the total by adding "*F" or to another fleet by adding "*F[f]" where f is the fleet number. The same age range will always be used.
##' If the fleet is omitted (e.g., F[2-4]), the target is for the total F.
##' If the age range is omitted (e.g., F[2]), the fbar range of the model is used.
##' Likewise, both fleet and age range can be omited (e.g., F=0.3) to specify a value for total F with the range used in the model.
##'
##' @section Catch/Landing based constraints:
##' Forecasts for catch and landing values are specified by the format "C[f,a0-a1]=x" for catch and "L[f,a0-a1]" for landings. If the age range is omitted, all modelled ages are used. Otherwise, the format is similar to F based scenarios.
##' If an "*" is added to the target value, the target will be relative to the year before.
##' Further, the catch target for a fleet can be relative to the total by adding "*C" or to another fleet by adding "*C[f]" where f is the fleet number. The same age range will always be used. Likewise, relative landing targets can be specified using "*", "*L", or "*L[f]" for targets relative to last year, the total, or fleet f, respectively.
##'
##' @section SSB/TSB at the beginning of next year based constraints:
##' Forecasts for spawning stock biomass (SSB) and total stock biomass (TSB) values are specified by the format "SSB[a0-a1]=x" for SSB and "TSB[a0-a1]" for TSB. The format is similar to catch/landing based scenarios. However, fleets have no effect.
##' If an "*" is added to the target value, the target will be relative to the year before.
##' Note that SSB amd TSB used for catch constraints are at the beginning of the next year to avoid dependence on future F values. Therefore, the values will differ from the output SSB and TSB estimates if propM or propF are not zero.
##'
##' @section Combining constraints:
##' Constraints for different fleets can be combined by "&".
##' For example, "F[2-4]=0.5 & C[2]=10000" specifies that total Fbar over ages 2-4 should be 0.5 while the catch for the second residual catch fleet should be 10,000t.
##' The constraints cannot affect within-fleet selectivity. Therefore, a fleet can at most have one constraint per year, and the total number of constraints cannot exceed the number of catch fleets. That is, if a constraint is given for the sum of fleets, there must be at least one fleet without any constraints.
##' For fleets where no constraints are given, a constraint is set to keep their relative Fs constant.
##'
##' @section Values relative to previous year:
##' Catch constraints specified as specific values are inherently different from catch constraints specified as relative values, even if they lead to the same F. Catch constraints specified as relative values will propagate the uncertainty in, e.g, F from previous years whereas constraints specified as specific values will not. This is different from the \link{forecast} function where, for example, a forecast using fval is the same as a forecast using fscale, if they lead to the same F. 
##' 
##' @section Old specification:
##' It is also possible to specify forecast constraints in a way similar to the \link{forecast} function. 
##' There are four ways to specify a scenario. If e.g. four F values are specified (e.g. fval=c(.1,.2,.3,4)), then the first value is used in the year after the last assessment year (base.year + 1), and the three following in the three following years. Alternatively F's can be specified by a scale, or a target catch. Only one option can be used per year. So for instance to set a catch in the first year and an F-scale in the following one would write catchval=c(10000,NA,NA,NA), fscale=c(NA,1,1,1). If only NA's are specified in a year, the F model is used for forecasting. The length of the vector specifies how many years forward the scenarios run. Unlike the forecast function, no value should be given for the base year.
##' Internally, the old specification is translated such that "fval=x" becomes "F=x", "fscale=x" becomes "F=x*", "catchval=x" becomes "C=x", "nextssb=x" becomes "SSB=x", and "landval=x" becomes "L=x".
##'
##' @section Forecasts using Laplace approximation or simulations
##' 
##'
##' @section Warnings:
##' Long term forecasts with random walk recruitment can lead to unstable behaviour and difficulties finding suitable F values for the constraints.
##' If no suitable F value can be found, an error message will be shown, and F values will be NA or NaN. Likewise, forecasts leading to high F values in some years may cause problems for the optimization as they will be used as starting values for the next years.
##' Since the model works on log space, all target values should be strictly positive. Values too close to zero may cause problems.
##'
##'
##' 
##' @return an object of type samforecast
##' @seealso forecast
##' @importFrom methods formalArgs
##' @importFrom stats var
##' @importFrom utils tail txtProgressBar setTxtProgressBar
##' @rdname modelforecast
##' @method modelforecast sam
##' @export
modelforecast.sam <- function(fit,
                              constraints = NULL,
                              fscale = NULL,
                              catchval = NULL,
                              fval = NULL,
                              nextssb = NULL,
                              landval = NULL,
                              findMSY = NULL,
                              hcr = NULL,
                              nosim = 0,
                              year.base = max(fit$data$years),
                              ave.years = c(),
                              rec.years = c(), #max(fit$data$years)+(-9:0),
                              label = NULL,
                              overwriteSelYears = NULL,
                              deterministicF = FALSE,
                              processNoiseF = FALSE,
                              resampleFirst = !is.null(nosim) && nosim > 0,
                              customSel = NULL,
                              lagR = FALSE,
                              splitLD = FALSE,
                              addTSB = FALSE,
                              biasCorrect = FALSE,
                              returnAllYears = FALSE,
                              nCatchAverageYears = 1,
                              returnObj = FALSE,
                              hcrConf = numeric(0),
                              hcrCurrentSSB = 0,
                              progress = TRUE,
                              estimate = median,
                              silent = TRUE,
                              newton_config = NULL,
                              ...
                              ){

    if(!is.null(nosim) && nosim > 0){ 
        estimateLabel <- deparse1(substitute(estimate))
    }else{
        estimateLabel <- "mostLikelyTrajectory"
    }
 
    
    if(progress && !returnObj && !is.null(nosim) && nosim > 0){
        pb <- utils::txtProgressBar(min = 0, max = nosim+3, style = 3)
        incpb <- function() utils::setTxtProgressBar(pb, pb$getVal()+1)
    }else{
        incpb <- function(){ return(invisible(NULL)) }
    }

    ## Handle year.base < max(fit$data$years)
    if(year.base > max(fit$data$years)){
        stop("")
    }else if(year.base < max(fit$data$years)){
        warning("year.base is ignored for now")
    }

    if(length(ave.years) == 0){
        useModelBio <- TRUE
        ave.years = max(fit$data$years)+(-4:0)
    }else{
        useModelBio <- FALSE
    }

    ## Checks
    if(deterministicF && length(fscale) > 0 && any(!is.na(fscale)) && is.null(customSel))
        warning("Forecasted F values may depend on the last estimated F vector and can therefore have uncertainty. Provide a custom selectivity to circumvent this.")
    
    
    ## Get number of forecast years
    lengthVec <- c(length(constraints),
                   length(fscale),
                   length(catchval),
                   length(fval),length(nextssb),length(landval),
                   length(hcr))
    if(any(lengthVec > 0 & lengthVec < max(lengthVec)))
        stop("All target vectors must have the same length")    
    nYears <- max(length(constraints),length(fscale),length(catchval),length(fval),length(nextssb),length(landval),length(findMSY), length(hcr))

    ## Convert input to an F model code and a target value
    if(is.null(constraints))
        constraints <- rep(NA_character_, nYears)    

    if(is.null(fscale))
        fscale <- rep(NA_real_, nYears)
    if(any(!is.na(constraints) & !is.na(fscale)))
        warning("fscale specified for years with other constraints. Using previously defined constraints.")
    constraints[is.na(constraints) & !is.na(fscale)] <- sprintf("F=%f*",fscale[is.na(constraints) & !is.na(fscale)])

    if(is.null(catchval))
        catchval <- rep(NA_real_, nYears)
    if(any(!is.na(constraints) & !is.na(catchval)))
        warning("catchval specified for years with other constraints. Using previously defined constraints.")
    constraints[is.na(constraints) & !is.na(catchval)] <- sprintf("C=%f",catchval[is.na(constraints) & !is.na(catchval)])

    if(is.null(fval))
        fval <- rep(NA_real_, nYears)
    if(any(!is.na(constraints) & !is.na(fval)))
        warning("fval specified for years with other constraints. Using previously defined constraints.")
    constraints[is.na(constraints) & !is.na(fval)] <- sprintf("F=%f",fval[is.na(constraints) & !is.na(fval)])
    
    if(is.null(nextssb))
        nextssb <- rep(NA_real_, nYears)
    if(any(!is.na(constraints) & !is.na(nextssb)))
        warning("nextssb specified for years with other constraints. Using previously defined constraints.")
constraints[is.na(constraints) & !is.na(nextssb)] <- sprintf("SSB=%f",nextssb[is.na(constraints) & !is.na(nextssb)])

    if(is.null(landval))
        landval <- rep(NA_real_, nYears)
    if(any(!is.na(constraints) & !is.na(landval)))
        warning("landval specified for years with other constraints. Using previously defined constraints.")
    constraints[is.na(constraints) & !is.na(landval)] <- sprintf("L=%f",landval[is.na(constraints) & !is.na(landval)])

    if(is.null(findMSY))
        findMSY <- rep(NA_real_, nYears)
    if(any(!is.na(constraints) & !is.na(findMSY)))
        warning("findMSY specified for years with other constraints. findMSY will overwrite other values.")

    if(is.null(hcr))
        hcr <- rep(NA_real_, nYears)
    if(any(!is.na(constraints) & !is.na(hcr)))
        warning("hcr specified for years with other constraints. hcr will overwrite other values.")
    
    if(any(!is.na(nextssb)))
        warning("The nextssb target is not currently supported.")
    if(any(!is.na(nextssb)) && (any(fit$data$propM != 0) || any(fit$data$propM != 0)))
        warning("The nextssb target is at the beginning of the year.")
    
    ## tab <- rbind(fscale,fval,catchval,nextssb,landval, findMSY, hcr)
    ## FModel <- apply(tab,2, function(x){
    ##     y <- which(!is.na(x))
    ##     switch(as.character(length(y)),
    ##            "0"=0,
    ##            "1"=y,
    ##            stop("At most one target can be specified per year."))
    ## })
    ## target <- apply(tab,2, function(x){
    ##     y <- which(!is.na(x))
    ##     switch(as.character(length(y)),
    ##            "0"=NA_real_,
    ##            "1"=x[y],
    ##            stop("At most one target can be specified per year."))
    ## })
    FModel <- rep(0,nYears)
    FModel[!is.na(constraints)] <- 1
    FModel[!is.na(findMSY)] <- 3
    FModel[!is.na(hcr)] <- 4
    
    nYears <- length(constraints)
    cstr <- replicate(nYears, .forecastDefault(), simplify = FALSE)
    cstr[!is.na(constraints)] <- .parseForecast(constraints[!is.na(constraints)], fit$conf$fbarRange, fit$data$fleetTypes, c(fit$conf$minAge,fit$conf$maxAge))

    ## Use custom selectivity?
    if(is.null(customSel)){
        customSel <- numeric(0)
        if(!is.null(overwriteSelYears)){
            fromto <- fit$conf$fbarRange-(fit$conf$minAge-1)  
            Ftab <- faytable(fit)
            customSel <- colMeans(Ftab[as.integer(rownames(Ftab)) %in% overwriteSelYears, , drop=FALSE])
            customSel <- customSel/mean(customSel[fromto[1]:fromto[2]])
        }
    }else{
        if(!is.null(overwriteSelYears))
            warning("overwriteSelYears is ignored when customSel is given.")
        fromto <- fit$conf$fbarRange-(fit$conf$minAge-1)  
        customSel <- customSel/mean(customSel[fromto[1]:fromto[2]])
    }

    ## Get recruitment model
    if(length(rec.years) == 0){
        recModel <- rep(0,nYears)
        logRecruitmentMedian <- NA_real_
        logRecruitmentVar <- NA_real_
    }else{
        rectab <- rectable(fit)
        recpool <- rectab[rownames(rectab)%in%rec.years,1]
        recModel <- rep(1,nYears)
        logRecruitmentMedian <- median(log(recpool))
        logRecruitmentVar <- stats::var(log(recpool))
    }

    ## Get F process time scale model
    ## By default, scale as random walk
    fsdTimeScaleModel <- rep(0,nYears)
    if(deterministicF){ ## 'Zero' variance of F process
        fsdTimeScaleModel <- rep(2,nYears)
    }else if(!processNoiseF){ ## Constant variance of F process
        fsdTimeScaleModel <- rep(1,nYears)
    }
    ## When F model is used, fsdTimeScaleModel should be 1
    fsdTimeScaleModel[FModel == 0] <- 1


    ## Convert average years to indices
    ave.yearsIn <- ave.years
    ave.years <- match(ave.years, fit$data$years) - 1
    if(any(is.na(ave.years)))
        stop("ave.years has years without data.")

    ## Prepare forecast
    obj0 <- fit$obj
    invisible(obj0$fn(fit$opt$par))
    invisible(obj0$gr(fit$opt$par))

    args <- as.list(obj0$env)[methods::formalArgs(TMB::MakeADFun)[methods::formalArgs(TMB::MakeADFun) != "..."]]
    args$silent <- silent
    pl <- fit$pl
    pl$logF <- cbind(pl$logF,matrix(pl$logF[,ncol(pl$logF)],nrow(pl$logF),nYears))
    pl$logN <- cbind(pl$logN,matrix(pl$logN[,ncol(pl$logN)],nrow(pl$logN),nYears))
    if(useModelBio){
        extendBio <- function(x) rbind(x,matrix(x[nrow(x)],nYears,ncol(x)))
        if(nrow(pl$logitMO) > 0){            
            pl$logitMO <- extendBio(pl$logitMO)
        }else{
            warning(sprintf("No MO random effects. Using data average over %s.",paste(ave.yearsIn,collapse=", ")))
        }
        if(nrow(pl$logNM) > 0){            
            pl$logNM <- extendBio(pl$logNM)
        }else{
            warning(sprintf("No NM random effects. Using data average over %s.",paste(ave.yearsIn,collapse=", ")))
        }
        if(nrow(pl$logSW) > 0){            
            pl$logSW <- extendBio(pl$logSW)
        }else{
            warning(sprintf("No SW random effects. Using data average over %s.",paste(ave.yearsIn,collapse=", ")))
        }
        if(nrow(pl$logCW) > 0){            
            pl$logCW <- extendBio(pl$logCW)
        }else{
            warning(sprintf("No CW random effects. Using data average over %s.",paste(ave.yearsIn,collapse=", ")))
        }
    }
    args$parameters <- pl
    args$random <- unique(names(obj0$env$par[obj0$env$random]))
    args$data$reportingLevel <- 0
    args$data$forecast <- list(nYears = as.numeric(nYears),
                               nCatchAverageYears = as.numeric(nCatchAverageYears),
                               aveYears = as.numeric(ave.years),
                               forecastYear = as.numeric(c(rep(0,fit$data$noYears),seq(1,nYears,length=nYears))),
                               FModel = as.numeric(FModel),
                               ##target = as.numeric(target),
                               constraints = cstr,                               
                               cfg = newton_config,
                               selectivity = as.numeric(customSel),
                               recModel = as.numeric(recModel),
                               logRecruitmentMedian = as.numeric(logRecruitmentMedian),
                               logRecruitmentVar = as.numeric(logRecruitmentVar),
                               fsdTimeScaleModel = as.numeric(fsdTimeScaleModel),
                               simFlag = c(0,0),
                               hcrConf = hcrConf,
                               hcrCurrentSSB = hcrCurrentSSB)

    if(any(!is.na(findMSY))){
        args$map$logFScaleMSY <- NULL
        return(args)
    }
    ## Create forecast object
    if(!is.null(nosim) && nosim > 0){
        args$type <- "Fun"
        args$integrate <- NULL
        args$random <- NULL
    }

    ## Done with initial work chunk
    incpb()

    obj <- do.call(TMB::MakeADFun, args)
    ## Done with initial MakeADFun
    incpb()

    if(returnObj)
        return(obj)

    fleetHasF <- apply(fit$conf$keyLogFsta>-1,1,any)
    if(!is.null(nosim) && nosim > 0){
        if(year.base==max(fit$data$years)){
            est <- fit$sdrep$estY
            cov <- fit$sdrep$covY
        }
        if(year.base==(max(fit$data$years)-1)){
            stop("year.base before last assessment year is not implemented yet")
            est <- fit$sdrep$estYm1
            cov <- fit$sdrep$covYm1
        }
        names(est) <- gsub("(^.*[lL]ast)(Log[NF]$)","\\2",names(est))
        i0 <- which(fit$data$year == year.base)
        plMap <- pl
        map <- fit$obj$env$map
        with.map <- intersect(names(plMap), names(map))
        applyMap <- function(par.name) {
            tapply(plMap[[par.name]], map[[par.name]], mean)
        }
        plMap[with.map] <- sapply(with.map, applyMap, simplify = FALSE)
        sniii <- 1
        doSim <- function(){
            sim0 <- est 
            if(resampleFirst)
                sim0 <- rmvnorm(1, mu=est, Sigma=cov)
            estList0 <- split(as.vector(sim0), names(est))
            p <- unlist(plMap)
            names(p) <- rep(names(plMap), times = sapply(plMap,length))
            ## Only works when year.base is last assessment year
            indxN <- matrix(which(names(p) %in% "logN"),nrow=length(estList0$LogN))[,i0]
            indxF <- matrix(which(names(p) %in% "logF"),nrow=length(estList0$LogF))[,i0]
            p[indxN] <- estList0$LogN
            p[indxF] <- estList0$LogF
            v <- obj$simulate(par = p)
            sniii <<- sniii+1
            incpb()
            return(v)
        }
        simvals <- replicate(nosim, doSim(), simplify = FALSE)
        simlist <- vector("list",length(FModel) + 1)
        for(i in 0:(length(FModel))){
            y<-year.base+i
            ii <- i0 + i
            simlist[[i+1]] <- list(sim = do.call("rbind",lapply(simvals,function(x) c(x$logN[,ii], x$logF[,ii]))),
                                   fbar = sapply(simvals,function(x) exp(x$logfbar[ii])),
                                   catch = sapply(simvals,function(x) exp(x$logCatch[ii])),
                                   ssb = sapply(simvals,function(x) exp(x$logssb[ii])),
                                   rec = sapply(simvals,function(x) exp(x$logN[1,ii])),
                                   cwF = rep(NA, nosim),
                                   catchatage = do.call("cbind",lapply(simvals,function(x) exp(x$logCatchAge[,ii]))),
                                   catchbyfleet = do.call("cbind",lapply(simvals,function(x) t(exp(x$logCatchByFleet[ii,fleetHasF,drop=FALSE])))),
                                   fbarbyfleet = do.call("cbind",lapply(simvals,function(x) exp(x$logFbarByFleet[fleetHasF,ii,drop=FALSE]))),
                                   land = sapply(simvals,function(x) exp(x$logLand[ii])),
                                   fbarL = sapply(simvals,function(x) exp(x$logfbarL[ii])),
                                   tsb = sapply(simvals,function(x) exp(x$logtsb[ii])),
                                   year=y)
            rownames(simlist[[i+1]]$catchatage) <- seq(fit$conf$minAge,fit$conf$maxAge,1)
        }
        attr(simlist, "fit")<-fit
        ## Similar to stockassessment::forecast
        collect <- function(x){
            est <- estimate(x)
            quan <- unname(quantile(x, c(.025,.975), na.rm = TRUE))
            v <- c(estimate=est, low=quan[1], high=quan[2])
            names(v)  <- c(estimateLabel, "low","high")
            v
        }
        fbar <- round(do.call(rbind, lapply(simlist, function(xx)collect(xx$fbar))),3)
        fbarL <- round(do.call(rbind, lapply(simlist, function(xx)collect(xx$fbarL))),3)  
        rec <- round(do.call(rbind, lapply(simlist, function(xx)collect(xx$rec))))
        ssb <- round(do.call(rbind, lapply(simlist, function(xx)collect(xx$ssb))))
        tsb <- round(do.call(rbind, lapply(simlist, function(xx)collect(xx$tsb))))
        catch <- round(do.call(rbind, lapply(simlist, function(xx)collect(xx$catch))))
        land <- round(do.call(rbind, lapply(simlist, function(xx)collect(xx$land))))  
        caytable<-round(do.call(rbind, lapply(simlist, function(xx)apply(xx$catchatage,1,collect))))
        cbftable<-round(do.call(rbind, lapply(simlist, function(xx)apply(xx$catchbyfleet,1,collect))))
        fbftable<-round(do.call(rbind, lapply(simlist, function(xx)apply(xx$fbarbyfleet,1,collect))),3)
        colnames(fbftable) <- attr(fit$data,"fleetNames")[fleetHasF]
        colnames(cbftable) <- attr(fit$data,"fleetNames")[fleetHasF]

        tab <- cbind(fbar,rec,ssb,catch)
        if(splitLD){
            tab<-cbind(tab,fbarL,fbar-fbarL,land,catch-land)
        }
        if(addTSB){
            tab<-cbind(tab,tsb)
        }
        ## if(!missing(customWeights)) tab <- cbind(tab,cwF=round(do.call(rbind, lapply(simlist, function(xx)collect(xx$cwF))),3))
        rownames(tab) <- unlist(lapply(simlist, function(xx)xx$year))
        nam <- c(estimateLabel,"low","high")
        basename<-c("fbar:","rec:","ssb:","catch:")
        if(splitLD){
            basename<-c(basename,"fbarL:","fbarD:","Land:","Discard:")    
        }
        if(addTSB){
            basename<-c(basename,"tsb:")    
        }
        ## if(!missing(customWeights)){
        ##     basename<-c(basename,"cwF:")    
        ## }
        colnames(tab)<-paste0(rep(basename, each=length(nam)), nam)
        
        attr(simlist, "tab")<-tab
        shorttab<-t(tab[,grep(estimateLabel,colnames(tab))])
        rownames(shorttab)<-sub(paste0(":",estimateLabel),"",paste0(label,if(!is.null(label))":",rownames(shorttab)))
        attr(simlist, "shorttab")<-shorttab
        attr(simlist, "label") <- label
        attr(simlist, "caytable")<-caytable        
        attr(simlist, "catchby")<-cbftable
        attr(simlist, "fbarby")<-fbftable
        attr(simlist, "nosim") <- nosim
        class(simlist) <- "samforecast"
        ## Done with reporting
        incpb()
        if(progress)
            close(pb)
        return(simlist)
    }else{
        invisible(obj$fn(fit$opt$par))
        ## Get results
        sdr <- TMB::sdreport(obj, fit$opt$par, svd_solve(fit$sdrep$cov.fixed),
                             bias.correct= biasCorrect,
                             skip.delta.method = biasCorrect,
                             bias.correct.control = list(sd = TRUE,
                                                         split = lapply(obj$env$ADreportIndex()[c("logfbar","logssb","logR","logCatch","logtsb","logLagR","logLand","logDis","loglandfbar","logdisfbar")[c(TRUE,TRUE,TRUE,TRUE,addTSB,lagR,splitLD,splitLD,splitLD,splitLD)]], utils::tail, n = nYears + 1 + (fit$data$noYears-1) * as.numeric(returnAllYears))
                                                         )
                             )
        ssdr <- summary(sdr)
        invisible(obj$fn(fit$opt$par))       
        rp <- obj$report(obj$env$last.par)

        simlist <- list()
        for(i in 0:(length(FModel))){
            y<-year.base+i 
            simlist[[i+1]] <- list(sim=NA, fbar=NA, catch=NA, ssb=NA, rec=NA,
                                   cwF=NA, catchatage=NA, catchbyfleet=NA, fbarbyfleet=NA, land=NA, fbarL=NA, tsb=NA, year=y)
        }

        attr(simlist, "fit")<-fit

        toCI <- function(x, trans = exp){
            trans(x %*% matrix(c(1,0,1,-2,1,2), nrow = 2, ncol =3))
        }

        indx <- 1:2
        if(biasCorrect)
            indx <- 3:4
        
        fbar <- toCI(ssdr[rownames(ssdr) %in% "logfbar",indx])
        rec <- toCI(ssdr[rownames(ssdr) %in% "logR",indx])
        if(lagR)
            rec <- toCI(ssdr[rownames(ssdr) %in% "logLagR",indx])
        ssb <- toCI(ssdr[rownames(ssdr) %in% "logssb",indx])
        catch <- toCI(ssdr[rownames(ssdr) %in% "logCatch",indx])
        cayvec <- toCI(ssdr[rownames(ssdr) %in% "logCatchAge",indx])
        cbfvec <- toCI(ssdr[rownames(ssdr) %in% "logCatchByFleet",indx])
        fbfvec <- toCI(ssdr[rownames(ssdr) %in% "logFbarByFleet",indx])
       
        tab <- cbind(fbar,rec,ssb,catch)
        if(splitLD){
            land <- toCI(ssdr[rownames(ssdr) %in% "logLand",indx])
            fbarL <- toCI(ssdr[rownames(ssdr) %in% "loglandfbar",indx])
            dis <- toCI(ssdr[rownames(ssdr) %in% "logDis",indx])
            fbarD <- toCI(ssdr[rownames(ssdr) %in% "logdisfbar",indx])
            tab<-cbind(tab,fbarL,fbarD,land,dis)
        }
        if(addTSB){
            tsb <- toCI(ssdr[rownames(ssdr) %in% "logtsb",indx])
            tab<-cbind(tab,tsb)
        }
        
        ## Handle cwF !!
        
        ## Row and column names on table
        futureYears <- unlist(lapply(simlist, function(xx)xx$year))
        rownames(tab) <- sort(unique(c(fit$data$years, futureYears)))
        fullTable <- tab
        tab <- tab[as.numeric(rownames(tab)) %in% futureYears, , drop = FALSE]
        
        nam <- c(estimateLabel,"low","high")
        basename<-c("fbar:","rec:","ssb:","catch:")
        if(splitLD){
            basename<-c(basename,"fbarL:","fbarD:","Land:","Discard:")    
        }
        if(addTSB){
            basename<-c(basename,"tsb:")    
        }
        ## if(!missing(customWeights)){
        ##     basename<-c(basename,"cwF:")    
        ## }

        colnames(tab)<-paste0(rep(basename, each=length(nam)), nam)
        if(returnAllYears || !biasCorrect)
            colnames(fullTable) <- colnames(tab)
        attr(simlist, "tab")<-tab
        shorttab<-t(tab[,grep(estimateLabel,colnames(tab))])
        rownames(shorttab)<-sub(paste0(":",estimateLabel),"",paste0(label,if(!is.null(label))":",rownames(shorttab)))

        ## Make caycbftable and fbftable
#### cay
        ii <- matrix(seq_along(rp$logCatchAge), nrow(rp$logCatchAge), ncol(rp$logCatchAge))[,as.numeric(rownames(fullTable)) %in% futureYears,drop=FALSE]
        caytable <- do.call("rbind",lapply(seq_len(ncol(ii)), function(yy){
            v <- t(cayvec[ii[,yy],,drop=FALSE])
        }))
        #### cbf
        ii <- matrix(seq_along(rp$logCatchByFleet), nrow(rp$logCatchByFleet), ncol(rp$logCatchByFleet))[as.numeric(rownames(fullTable)) %in% futureYears,fleetHasF,drop=FALSE]
        cbftable <- do.call("rbind",lapply(seq_len(nrow(ii)), function(yy){
            v <- t(cbfvec[ii[yy,],,drop=FALSE])
        }))
        #### fay
        ii <- matrix(seq_along(rp$logFbarByFleet), nrow(rp$logFbarByFleet), ncol(rp$logFbarByFleet))[fleetHasF,as.numeric(rownames(fullTable)) %in% futureYears,drop=FALSE]
        fbftable <- do.call("rbind",lapply(seq_len(ncol(ii)), function(yy){
            v <- t(fbfvec[ii[,yy],,drop=FALSE])
        }))
        #### dimnames
        rownames(caytable) <- rep(c(estimateLabel,"low","high"), length.out = nrow(caytable))
        rownames(cbftable) <- rownames(fbftable) <- rep(c(estimateLabel,"low","high"), length.out = nrow(cbftable))
        colnames(cbftable) <- colnames(fbftable) <- attr(fit$data,"fleetNames")[fleetHasF]
        colnames(caytable) <- seq(fit$conf$minAge,fit$conf$maxAge,1)

        ##

        
        attr(simlist, "shorttab")<-shorttab
        attr(simlist, "label") <- label
        attr(simlist, "caytable")<-caytable        
        attr(simlist, "catchby")<-cbftable
        attr(simlist, "fbarby")<-fbftable
        attr(simlist, "fulltab") <- fullTable
        attr(simlist,"nosim") <- 0
        class(simlist) <- "samforecast"
        return(simlist)    
    }
}
